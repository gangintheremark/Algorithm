 알고리즘

## 1주차 시간복잡도 
 > 시간복잡도의 개념과 분석 방법론, 그리고 점근적 표기법에 대한 이해

 ### 시간복잡도
 - 실행시간은 실행환경 ( 하드웨어, 운영체제, 언어, 컴파일러 등) 에 따라 달라짐
 - 실행 시간을 측정하는 대신 **연산의 실행 횟수**를 카운트
 - 연산의 실행 횟수는 **입력 데이터의 크기에 관한 함수**로 표현
 - 데이터의 크기가 같더라도 실제 데이터에 따라서 달라짐 
   - 최악의 경우 시간 복잡도 
   - 평균 시간 복잡도  

### 점근적 분석의 예

- 상수 시간복잡도 
> 입력으로 n개의 데이터가 저장된 배열 data가 주어지고, 그 중 n/2번째 데이터를 반환한다.
```
int sample(int data[], int n)
{
  int k = n/2;
  return data[k];
}
```
> n에 상관없이 상수 시간이 소요된다. <br>
> 이 경우 알고리즘의 시간복잡도는 O(1)이다.

- 선형 시간복잡도 
> 입력으로 n개의 데이터가 저장된 배열 data가 주어지고, 그 합을 구하여 반환한다.
```
int sum(int data[], int n)
{
  int sum = 0;
  for(int i = 0; i < n; i++)
     sum = sum + data[i];
  return sum;
}
```
> 실행 횟수는 항상 n번이다. <br> 
> 이 경우 알고리즘의 시간복잡도는 O(n)이다. 

- Quadratic
> 배열 x에 중복된 원소가 있는지 검사하는 함수이다.
```
bool is_distinct(int n, int x[])
{
  for(int i = 0; i < n; i++)
     for(int j = i + 1; j < n; j++)
         if(x[i] == x[j])
            return false;
  return true;
}
```
> 최악의 경우 배열에 저장된 모든 원소 쌍을 비교하므로 실행 횟수는 n(n-1)/2 번 이다. <br> 
> 최악의 경우 시간복잡도는 O(n<sup>2</sup>)이다.

- log 시간복잡도
```
for( int i = 1; i < n ; i *= 2 ) {
  // do somthing
}
```
>  알고리즘은 n=2 일 때 실행횟수 1, n=3 일 때 실행횟수 1, n=4 일 때 실행횟수 2 ... 로 실행횟수는 log<sub>2</sub>n이다. <br>
> 따라서 시간복잡도는 O(log<sub>2</sub>n) 이다. 